"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
const { validate } = require('jsonschema');
const schema = require('./ManifestSchema.json');
const constants = require("./constants");
const diagnosticMessages_generated_1 = require("./diagnosticMessages.generated");
class ManifestSchemaValidator {
    constructor(data, diag) {
        this.parsedJson = data;
        this.diag = diag;
    }
    validateManifest() {
        if (!this.parsedJson) {
            this.diag.pushA(diagnosticMessages_generated_1.strings.manifest_empty, [constants.MANIFEST_INPUT_FILE_NAME]);
            return;
        }
        // schema validation
        const result = validate(this.parsedJson, schema);
        if (!result.valid) {
            result.errors.forEach(err => this.diag.pushA(diagnosticMessages_generated_1.strings.manifest_validation_error, [err.stack]));
            return;
        }
        const controlNode = this.parsedJson.manifest.control[0];
        // At least one <data-set> node or <property> should be present
        if (!controlNode['data-set'] && !controlNode.property) {
            this.diag.push(diagnosticMessages_generated_1.strings.validation_noexistent_dataset_property);
        }
        // json schema doesn't support the verification of uniqueness of a specific identifier among an array of objects
        // hence manually validating that properties, values, datasets and type-groups all have unique "name" attributes
        const typeGroupNames = this.validateTypeGroupNodes(controlNode['type-group']);
        this.validatePropertyNodes(controlNode.property, typeGroupNames);
        this.validateDatasetNodes(controlNode['data-set'], controlNode.property, typeGroupNames);
        this.validateFeatureUsageNodes(controlNode['feature-usage']);
    }
    validatePropertyNodes(propertyNodes, typeGroupNames, isPropertySet) {
        const key = isPropertySet ? 'property-set' : 'property';
        const propNames = new Set();
        if (propertyNodes) {
            propertyNodes.forEach(prop => {
                if (propNames.has(prop.$.name)) {
                    this.diag.pushA(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, [key, prop.$.name]);
                }
                else {
                    propNames.add(prop.$.name);
                }
                if (prop.$['of-type-group'] && !typeGroupNames.has(prop.$['of-type-group'])) {
                    this.diag.pushA(diagnosticMessages_generated_1.strings.validation_nonexistent_typegroup, [key, prop.$.name]);
                }
                this.validateValueNodes(prop.value, prop.$.name);
            });
        }
    }
    validateDatasetNodes(datasetNodes, propertyNodes, typeGroupNames) {
        const datasetNames = new Set();
        if (datasetNodes) {
            datasetNodes.forEach(dataset => {
                if (datasetNames.has(dataset.$.name)) {
                    this.diag.pushA(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, ['data-set', dataset.$.name]);
                }
                else {
                    datasetNames.add(dataset.$.name);
                }
                this.validatePropertyNodes(dataset['property-set'], typeGroupNames, true);
            });
        }
        // When <data-set> is present usage attribute of <property> can only be 'input'.
        if (datasetNodes && propertyNodes) {
            propertyNodes.forEach(prop => {
                if (prop.$.usage !== 'input') {
                    this.diag.pushA(diagnosticMessages_generated_1.strings.validation_property_usage_not_input, [prop.$.name, prop.$.usage]);
                }
            });
        }
    }
    validateTypeGroupNodes(typeGroups) {
        const typeGroupNames = new Set();
        if (typeGroups) {
            typeGroups.forEach(tg => {
                if (typeGroupNames.has(tg.$.name)) {
                    this.diag.pushA(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, ['type-group', tg.$.name]);
                }
                else {
                    typeGroupNames.add(tg.$.name);
                }
            });
        }
        return typeGroupNames;
    }
    validateValueNodes(values, propName) {
        const enumValueNames = new Set();
        const enumValues = new Set();
        if (values) {
            values.forEach(val => {
                if (enumValueNames.has(val.$.name)) {
                    this.diag.pushA(diagnosticMessages_generated_1.strings.validation_duplicate_child_element_name, ['value', val.$.name, 'property', propName]);
                }
                else {
                    enumValueNames.add(val.$.name);
                }
                if (enumValues.has(val._)) {
                    this.diag.pushA(diagnosticMessages_generated_1.strings.validation_duplicate_enum_value, [val._, 'property', propName]);
                }
                else {
                    enumValues.add(val._);
                }
            });
        }
    }
    validateFeatureUsageNodes(featureUsageNode) {
        const usesFeatureNames = new Set();
        if (featureUsageNode && featureUsageNode[0] && featureUsageNode[0]['uses-feature']) {
            featureUsageNode[0]['uses-feature'].forEach(usesFeature => {
                if (usesFeatureNames.has(usesFeature.$.name)) {
                    this.diag.pushA(diagnosticMessages_generated_1.strings.validation_duplicate_element_name, ['uses-feature', usesFeature.$.name]);
                }
                else {
                    usesFeatureNames.add(usesFeature.$.name);
                }
            });
        }
        return usesFeatureNames;
    }
}
exports.ManifestSchemaValidator = ManifestSchemaValidator;
