"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const validateTask_1 = require("./tasks/validateTask");
const manifestTypesTask_1 = require("./tasks/manifestTypesTask");
const outputTask_1 = require("./tasks/outputTask");
const chokidar = require('chokidar');
const constants = require("./constants");
const path = require("path");
class PCFFileWatcher {
    constructor() {
        this._isReady = false;
    }
    // Returning promise is resolved only when watcher is ready. Mainly needed for testing purposes.
    start(context, watchBehavior) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const pathsToWatchArr = yield this.getUpdatedPathsToWatch(context);
                const pathsToWatch = pathsToWatchArr[0];
                return new Promise((resolve, reject) => {
                    this._watcher = chokidar.watch(pathsToWatch, { awaitWriteFinish: {
                            stabilityThreshold: 2000,
                            pollInterval: 100
                        } })
                        .on('ready', () => {
                        this._isReady = true;
                        return resolve('Watch is now ready');
                    })
                        .on('change', (filePath) => {
                        if (!this._isReady) {
                            return;
                        }
                        if (watchBehavior) {
                            watchBehavior(context);
                        }
                        else {
                            this.processFileChange(filePath, context).catch(() => context.getDiagnostic().flush(true));
                        }
                    });
                });
            }
            catch (error) {
                context.getDiagnostic().flush(true);
            }
        });
    }
    getUpdatedPathsToWatch(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const pathsToWatch = [];
            return context.mapControls((control) => {
                const manifestPath = path.resolve(control.getControlPath(), constants.MANIFEST_INPUT_FILE_NAME);
                pathsToWatch.push(manifestPath);
                let resourcePaths = control.getControlManifest().getResources(true);
                for (let resourcePath of resourcePaths) {
                    pathsToWatch.push(path.resolve(control.getControlPath(), resourcePath));
                }
                return Promise.resolve(pathsToWatch);
            });
        });
    }
    processFileChange(filePath, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (filePath.includes(constants.INDEX_FILE_NAME)) {
                if (this._errorsExist) {
                    return Promise.reject();
                }
            }
            else if (filePath.includes(constants.MANIFEST_INPUT_FILE_NAME)) {
                return this.recompileWatchedFiles(context)
                    .then(() => {
                    this._errorsExist = false;
                    return Promise.resolve();
                })
                    .catch(() => {
                    this._errorsExist = true;
                    return Promise.reject();
                });
            }
            else {
                const createOutputTask = new outputTask_1.CreateOutputTask;
                return createOutputTask.run(context)
                    .catch(() => {
                    this._errorsExist = true;
                    return Promise.reject();
                });
            }
        });
    }
    recompileWatchedFiles(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const diag = context.getDiagnostic();
            context.getDiagnostic().clear();
            return context.mapControls((control) => {
                return Promise.resolve(control.reloadManifest(diag));
            }).then(() => __awaiter(this, void 0, void 0, function* () {
                const validateManifestTask = new validateTask_1.ValidateManifestTask;
                const generateManifestTypesTask = new manifestTypesTask_1.GenerateManifestTypesTask;
                const createOutputTask = new outputTask_1.CreateOutputTask;
                yield validateManifestTask.run(context);
                yield generateManifestTypesTask.run(context);
                yield createOutputTask.run(context);
                yield this.updateWatchedPaths(context);
            }));
        });
    }
    updateWatchedPaths(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const oldWatchedPaths = this.getPreviousPathsToWatch();
            const newWatchedPathsArr = yield this.getUpdatedPathsToWatch(context);
            const newWatchedPaths = newWatchedPathsArr[0];
            const unwatchPaths = [];
            oldWatchedPaths.forEach((watchedPath) => {
                if (!newWatchedPaths.includes(watchedPath)) {
                    unwatchPaths.push(watchedPath);
                }
            });
            this._watcher.unwatch(unwatchPaths);
            this._watcher.add(newWatchedPaths);
            return Promise.resolve();
        });
    }
    stop() {
        if (!this._watcher) {
            return;
        }
        this._watcher.close();
    }
    getPreviousPathsToWatch() {
        const watchedPathsArray = [];
        const watchedPathsObject = this._watcher.getWatched();
        for (const directoryPath of Object.keys(watchedPathsObject)) {
            const pathsArr = watchedPathsObject[directoryPath];
            pathsArr.forEach((filePath) => {
                watchedPathsArray.push(path.join(directoryPath, filePath));
            });
        }
        return watchedPathsArray;
    }
}
exports.PCFFileWatcher = PCFFileWatcher;
