"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../../common/typings/controlmanifest.d.ts"/>
const ts = require("typescript");
// the following props are compatible number properties that can be grouped together in the same type group
const numberProperties = [
    'ComponentFramework.PropertyTypes.NumberProperty',
    'ComponentFramework.PropertyTypes.WholeNumberProperty',
    'ComponentFramework.PropertyTypes.DecimalNumberProperty',
    'ComponentFramework.PropertyTypes.FloatingNumberProperty'
];
class ManifestTypesGenerator {
    constructor() {
        // map each type group's name to its type name
        this.typeGroups = {};
        this.outputs = {};
        // map each property name defined in manifest to its type name
        this.parameters = {};
        this.dataSetNames = [];
    }
    getFieldType(type) {
        const prefix = type.split('.')[0];
        switch (prefix) {
            case 'SingleLine':
            case 'Multiple':
                return 'ComponentFramework.PropertyTypes.StringProperty';
            case 'Whole':
                return 'ComponentFramework.PropertyTypes.WholeNumberProperty';
            case 'TwoOptions':
                return 'ComponentFramework.PropertyTypes.TwoOptionsProperty';
            case 'DateAndTime':
                return 'ComponentFramework.PropertyTypes.DateTimeProperty';
            case 'Decimal':
                return 'ComponentFramework.PropertyTypes.DecimalNumberProperty';
            case 'FP':
                return 'ComponentFramework.PropertyTypes.FloatingNumberProperty';
            case 'Currency':
                return 'ComponentFramework.PropertyTypes.NumberProperty';
            case 'OptionSet':
                return 'ComponentFramework.PropertyTypes.OptionSetProperty';
            default:
                return 'ComponentFramework.PropertyTypes.Property';
        }
    }
    getTypeGroupType(tg) {
        let fieldType = '';
        let nextType;
        for (let type of tg.type) {
            // first type in the type group, set the base
            if (fieldType === '') {
                fieldType = this.getFieldType(type);
            }
            else {
                // else check whether the next type in the type group is compatible
                nextType = this.getFieldType(type);
                if (nextType !== fieldType) {
                    // incompatible types might all be NumberProperty
                    if (numberProperties.indexOf(nextType) > -1 && numberProperties.indexOf(fieldType) > -1) {
                        fieldType = 'ComponentFramework.PropertyTypes.NumberProperty';
                    }
                    else {
                        fieldType = 'ComponentFramework.PropertyTypes.Property';
                        break;
                    }
                }
            }
        }
        return fieldType;
    }
    // Get the type for props under IOutput interface (string, number, boolean or any)
    getOutputFieldType(type) {
        // Enum is always treated as string
        if (type.indexOf('ComponentFramework.PropertyTypes.EnumProperty') > -1) {
            return ts.SyntaxKind.StringKeyword;
        }
        switch (type) {
            case 'ComponentFramework.PropertyTypes.StringProperty':
                return ts.SyntaxKind.StringKeyword;
            case 'ComponentFramework.PropertyTypes.NumberProperty':
            case 'ComponentFramework.PropertyTypes.WholeNumberProperty':
            case 'ComponentFramework.PropertyTypes.DecimalNumberProperty':
            case 'ComponentFramework.PropertyTypes.FloatingNumberProperty':
            case 'ComponentFramework.PropertyTypes.OptionSetProperty':
                return ts.SyntaxKind.NumberKeyword;
            case 'ComponentFramework.PropertyTypes.TwoOptionsProperty':
                return ts.SyntaxKind.BooleanKeyword;
            default:
                return ts.SyntaxKind.AnyKeyword;
        }
    }
    getEnumType(propNode) {
        if (!propNode.value) {
            return 'ComponentFramework.PropertyTypes.EnumProperty<any>';
        }
        let enumType = '';
        let first = true;
        const values = propNode.value;
        for (const val of values) {
            if (!first) {
                enumType += ' | ';
            }
            else {
                first = false;
            }
            enumType += `"${val._}"`;
        }
        return `ComponentFramework.PropertyTypes.EnumProperty<${enumType}>`;
    }
    parseTypeGroupNode(typeGroups) {
        if (typeGroups) {
            for (const tg of typeGroups) {
                const typeGroupName = tg.$.name;
                const typeGroupType = this.getTypeGroupType(tg);
                this.typeGroups[typeGroupName] = typeGroupType;
            }
        }
    }
    parsePropertyNodes(props) {
        if (!props) {
            return;
        }
        for (const prop of props) {
            const propName = prop.$.name;
            let propType;
            // check if usage is defined; ignore those without a usage
            if (prop.$.usage) {
                if (prop.$['of-type-group']) {
                    if (prop.$['of-type-group'] in this.typeGroups) {
                        propType = this.typeGroups[prop.$['of-type-group']];
                    }
                    else {
                        throw new Error(`Type group ${prop.$['of-type-group']} not found.`);
                    }
                }
                else if (prop.$['of-type']) {
                    propType = prop.$['of-type'] === 'Enum' ? this.getEnumType(prop)
                        : this.getFieldType(prop.$['of-type']);
                }
                else {
                    propType = 'ComponentFramework.PropertyTypes.Property';
                }
                if (prop.$.usage === 'output' || prop.$.usage === 'bound') {
                    this.outputs[propName] = propType;
                }
                if (prop.$.usage === 'input' || prop.$.usage === 'bound') {
                    this.parameters[propName] = propType;
                }
            }
        }
    }
    parseDataSetNodes(dataSets) {
        if (!dataSets) {
            return;
        }
        this.dataSetNames = dataSets.map(set => set.$.name);
    }
    // Helper for making the AST of ManifestTypes.d.ts - create all properties under IInput interface
    createInputProperties() {
        const inputProperties = Object.keys(this.parameters).map(propName => {
            const typeRef = ts.createTypeReferenceNode(
            /*typeName*/ this.parameters[propName], 
            /*typeArguments*/ undefined);
            return ts.createPropertySignature(
            /*modifiers*/ undefined, 
            /*name*/ propName, 
            /*questionToken*/ undefined, 
            /*type*/ typeRef, 
            /*initializer*/ undefined);
        });
        const dataSetTypeRef = ts.createTypeReferenceNode(
        /*typeName*/ 'ComponentFramework.PropertyTypes.DataSet', 
        /*typeArguments*/ undefined);
        const dataSetsProperties = this.dataSetNames.map(name => {
            return ts.createPropertySignature(
            /*modifiers*/ undefined, 
            /*name*/ name, 
            /*questionToken*/ undefined, 
            /*type*/ dataSetTypeRef, 
            /*initializer*/ undefined);
        });
        return inputProperties.concat(dataSetsProperties);
    }
    // Helper for making the AST of ManifestTypes.d.ts - create all properties under IOutput interface
    createOutputProperties() {
        const outputProperties = Object.keys(this.outputs).map(propName => {
            let typeRef;
            // DateTimeProperty is a special case here - it doesn't have a keyword type defined in the API
            if (this.outputs[propName] === 'ComponentFramework.PropertyTypes.DateTimeProperty') {
                typeRef = ts.createTypeReferenceNode(
                /*typeName*/ 'Date', 
                /*typeArguments*/ undefined);
            }
            else {
                const keyword = this.getOutputFieldType(this.outputs[propName]);
                typeRef = ts.createKeywordTypeNode(keyword);
            }
            return ts.createPropertySignature(
            /*modifiers*/ undefined, 
            /*name*/ propName, 
            /*questionToken*/ ts.createToken(ts.SyntaxKind.QuestionToken), 
            /*type*/ typeRef, 
            /*initializer*/ undefined);
        });
        return outputProperties;
    }
    // Construct the full AST of ManifestTypes.d.ts
    makeAST() {
        const inputsInterface = ts.createInterfaceDeclaration(
        /*decorators*/ undefined, 
        /*modifiers*/ [ts.createToken(ts.SyntaxKind.ExportKeyword)], 
        /*name*/ 'IInputs', 
        /*typeParameters*/ undefined, 
        /*heritageClauses*/ undefined, 
        /*members*/ this.createInputProperties());
        const outputsInterface = ts.createInterfaceDeclaration(
        /*decorators*/ undefined, 
        /*modifiers*/ [ts.createToken(ts.SyntaxKind.ExportKeyword)], 
        /*name*/ 'IOutputs', 
        /*typeParameters*/ undefined, 
        /*heritageClauses*/ undefined, 
        /*members*/ this.createOutputProperties());
        return ts.createNodeArray([inputsInterface, outputsInterface], false);
    }
    // Use Typescript's printer API to generate the actual code from the AST
    generateManifestTypes(manifestObj) {
        this.parseTypeGroupNode(manifestObj.manifest.control['type-group']);
        this.parsePropertyNodes(manifestObj.manifest.control.property);
        this.parseDataSetNodes(manifestObj.manifest.control['data-set']);
        const resultFile = ts.createSourceFile(
        /*fileName*/ 'output.ts', 
        /*sourceText*/ '', 
        /*languageVersion*/ ts.ScriptTarget.Latest, 
        /*setParentNodes*/ false, 
        /*scriptKind*/ ts.ScriptKind.TS);
        const printer = ts.createPrinter({
            newLine: ts.NewLineKind.LineFeed
        });
        const result = printer.printList(ts.ListFormat.MultiLine, this.makeAST(), resultFile);
        return result;
    }
}
exports.ManifestTypesGenerator = ManifestTypesGenerator;
