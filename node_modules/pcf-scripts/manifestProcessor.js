"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../../common/typings/controlmanifest.d.ts"/>
const clonedeep = require('lodash/clonedeep');
const path = require('path');
const fs = require('fs');
const controlManifest_1 = require("./controlManifest");
const constants = require("./constants");
const diagnosticMessages_generated_1 = require("./diagnosticMessages.generated");
class ManifestProcessor {
    constructor(manifestData, controlPath, diag) {
        this.resourcesMap = {};
        this.nameTracker = {};
        this.processedManifest = clonedeep(manifestData);
        this.controlAbsPath = path.resolve(controlPath);
        this.controlRoot = path.dirname(this.controlAbsPath);
        this.diag = diag;
        this.nameTracker[constants.BUNDLE_NAME] = 1;
    }
    // rename paths in <code> and <library>.<packaged_library> under <resources>
    // add built-by element as a child of control node; stamp PCF API version used
    getProcessedManifest() {
        this.addBuiltBy();
        this.stampApiVersion();
        this.processResources();
        return {
            processedManifest: new controlManifest_1.ControlManifest(this.processedManifest),
            resourcesMap: this.resourcesMap
        };
    }
    // rename paths specified by preview-image attribute as well as <code> and <library>.<packaged_library> under <resources>
    processResources() {
        const resources = this.processedManifest.manifest.control.resources;
        const previewImagePath = this.processedManifest.manifest.control.$['preview-image'];
        if (previewImagePath) {
            this.processedManifest.manifest.control.$['preview-image'] = this.checkResourcePath(previewImagePath);
        }
        Object.keys(resources).forEach(resourceType => {
            if (resourceType === constants.CODE_ELEM_NAME) {
                // the xsd allows more than one <code> element, but our opinionated build will validate
                // there is only one <code> element
                resources[constants.CODE_ELEM_NAME][0].$.path = constants.BUNDLE_NAME;
            }
            else if (resourceType === constants.LIBRARY_ELEM_NAME) {
                resources[constants.LIBRARY_ELEM_NAME].forEach((lib) => {
                    const packagedLibs = lib.packaged_library;
                    if (packagedLibs) {
                        packagedLibs.forEach((packagedLib) => {
                            packagedLib.$.path = this.checkResourcePath(packagedLib.$.path);
                        });
                    }
                });
            }
            else {
                resources[resourceType].forEach((resource) => {
                    resource.$.path = this.checkResourcePath(resource.$.path);
                });
            }
        });
    }
    // add built-by element as a child of control node
    addBuiltBy() {
        const buildToolVersion = getPackageVersion(constants.PCF_SCRIPTS_PACKAGE_NAME, this.controlRoot);
        if (!buildToolVersion) {
            this.diag.pushA(diagnosticMessages_generated_1.strings.package_version_not_found, [constants.PCF_SCRIPTS_PACKAGE_NAME]);
            return;
        }
        this.processedManifest.manifest.control['built-by'] = {
            $: {
                name: constants.BUILD_TOOL_NAME,
                version: buildToolVersion
            }
        };
    }
    // obtain the version of the ComponentFramework API from the local package-lock.json and stamp it in CM.xml
    // optional parameter for unit test; return a boolean that indicates whether version info is found
    stampApiVersion() {
        const apiVersion = getPackageVersion(constants.COMPONENT_FRAMEWORK_PACKAGE_NAME, this.controlRoot);
        if (!apiVersion) {
            this.diag.pushA(diagnosticMessages_generated_1.strings.package_version_not_found, [constants.COMPONENT_FRAMEWORK_PACKAGE_NAME]);
            return;
        }
        this.processedManifest.manifest.control.$['api-version'] = apiVersion;
    }
    // First check whether the resource's relative path points to a file within the control folder.
    // If so, preserve the folder structure in outdir. If not, check whether a resource's file name collides
    // with any other resources file. If so returns a new file name otherwise return original name.
    checkResourcePath(resourceRelativePath) {
        const resourceName = path.basename(resourceRelativePath);
        const resourceAbsPath = path.join(this.controlAbsPath, resourceRelativePath);
        const simplifiedRelativePath = path.relative(this.controlAbsPath, resourceAbsPath);
        let relativePathInOutDir;
        if (!simplifiedRelativePath.startsWith('..') && simplifiedRelativePath.length > 0) {
            relativePathInOutDir = simplifiedRelativePath;
        }
        else {
            relativePathInOutDir = resourceName;
        }
        // convert windows format to the path format in manifest
        relativePathInOutDir = relativePathInOutDir.replace(/\\/g, '/');
        if (this.nameTracker[relativePathInOutDir]) {
            const ext = path.extname(relativePathInOutDir);
            const suffix = this.nameTracker[relativePathInOutDir];
            // increment a number as suffix to differentiate files with existing names
            const newResourcePath = `${relativePathInOutDir.substring(0, relativePathInOutDir.length - ext.length)}${suffix}${ext}`;
            this.nameTracker[relativePathInOutDir]++;
            this.resourcesMap[resourceRelativePath] = newResourcePath;
            return newResourcePath;
        }
        else {
            this.nameTracker[relativePathInOutDir] = 1;
            this.resourcesMap[resourceRelativePath] = relativePathInOutDir;
            return relativePathInOutDir;
        }
    }
}
exports.ManifestProcessor = ManifestProcessor;
function getPackageVersion(packageName, controlRoot) {
    let version;
    const pathToPackageLockJson = path.resolve(controlRoot, constants.PACKAGE_LOCK_JSON_PATH);
    let pathToPackageJson = path.resolve(controlRoot, constants.NODE_MODULES, packageName, constants.PACKAGE_JSON_PATH);
    const getVersion = (pathToJson) => {
        const packageJson = require(pathToJson);
        return packageJson && packageJson.version ? packageJson.version : undefined;
    };
    // find version from package-lock.json first
    if (fs.existsSync(pathToPackageLockJson)) {
        const packageLockJson = require(pathToPackageLockJson);
        if (packageLockJson && packageLockJson.dependencies && packageLockJson.dependencies[packageName]) {
            version = packageLockJson.dependencies[packageName].version;
        }
    }
    // fallback to find version in that package's package.json in node_modules
    if (!version && fs.existsSync(pathToPackageJson)) {
        version = getVersion(pathToPackageJson);
    }
    // add another fallback to search from the directory of the script itself. This can happen if the user has a customized folder structure
    // in which package-lock.json and node_modules don't live at the root of the control project.
    if (!version) {
        // go out one level to be at the root dir of node_modules folder
        pathToPackageJson = path.resolve(__dirname, '..', packageName, constants.PACKAGE_JSON_PATH);
        if (fs.existsSync(pathToPackageJson)) {
            version = getVersion(pathToPackageJson);
        }
    }
    return version;
}
exports.getPackageVersion = getPackageVersion;
