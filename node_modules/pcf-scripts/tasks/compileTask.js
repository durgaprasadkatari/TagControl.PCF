"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const webpack = require("webpack");
const webpackConfig_1 = require("../webpackConfig");
const diagnosticMessages_generated_1 = require("../diagnosticMessages.generated");
const constants = require("../constants");
const locale_1 = require("../generated/locale");
const pcfFileWatcher_1 = require("../pcfFileWatcher");
class CompileTask {
    getDescription() {
        return locale_1.translate(diagnosticMessages_generated_1.strings.task_compile_and_bundle.key);
    }
    setOptions(options) {
        this._options = options;
    }
    run(context) {
        return this.runBuild(context, false);
    }
    runBuild(context, isWatch, maxBundleSizeInBytes) {
        const buildMode = context.getBuildMode();
        const outDir = context.getOutDir();
        if (!outDir) {
            context.getDiagnostic().push(diagnosticMessages_generated_1.strings.buildconfig_no_outdir);
            return Promise.reject();
        }
        return context.mapControls((control) => {
            const controlOutputDir = path.resolve(outDir, control.getControlFolderName());
            const config = webpackConfig_1.getWebpackConfig(control, controlOutputDir, buildMode, isWatch);
            const bundlePath = path.join(controlOutputDir, constants.BUNDLE_NAME);
            const bundleSizeInBytes = maxBundleSizeInBytes || constants.MAX_BUNDLE_SIZE_IN_MB * 1024 * 1024;
            fs.ensureDirSync(controlOutputDir);
            return new Promise((resolve, reject) => webpack(config, (error, stats) => {
                let colorize = false;
                let toReject = false;
                const diag = context.getDiagnostic();
                if (this._options && this._options.colorize) {
                    colorize = true;
                }
                if (!isWatch || error || stats.hasErrors()) {
                    console.log(`[Webpack ${locale_1.translate(diagnosticMessages_generated_1.strings.statistics.key)}]:\n${stats.toString({ chunks: false, colors: colorize })}`);
                }
                if (error) {
                    this.addError(diagnosticMessages_generated_1.strings.build_error_generic, diag, error.message);
                    toReject = true;
                }
                else if (stats.hasErrors()) {
                    this.addError(diagnosticMessages_generated_1.strings.bundling_error, diag);
                    toReject = true;
                }
                else if (buildMode === 'production') {
                    let assets = stats.toJson().assets;
                    if (assets) {
                        assets = assets.filter(obj => obj.name === constants.BUNDLE_NAME);
                        // webpack stats object uses byte as unit
                        if (assets.length > 0 && assets[0].size > bundleSizeInBytes) {
                            this.addError(diagnosticMessages_generated_1.strings.bundle_size_exceeds_max, diag, (bundleSizeInBytes / (1024 * 1024)).toString());
                            toReject = true;
                        }
                    }
                }
                if (!control.getControlManifest().getManifestData().manifest) {
                    this.addError(diagnosticMessages_generated_1.strings.generating_stub_error, diag);
                    toReject = true;
                }
                if (toReject) {
                    return reject();
                }
                if (isWatch) {
                    diag.clear();
                } // remove old errors, only needed when watching
                const stub = webpackConfig_1.generateStub(control.getControlNamespace(), control.getControlName());
                fs.appendFileSync(bundlePath, stub, 'utf8');
                return resolve({ 'compileTime': stats.toJson().time });
            }));
        });
    }
    // In watch mode: need to check for duplication of errors in case they were not fixed from last save
    addError(error, diag, errorMessage) {
        let lastEntry;
        let secondToLastEntry;
        if (diag.length() > 0) {
            lastEntry = diag.peek();
            if (diag.length() > 1) {
                secondToLastEntry = diag.peek(diag.length() - 2);
            }
        }
        if (secondToLastEntry && lastEntry) {
            if (error.code !== secondToLastEntry.diag.code && error.code !== lastEntry.diag.code) {
                errorMessage ? diag.pushA(error, [errorMessage]) : diag.push(error);
            }
        }
        else if (lastEntry) {
            if (error.code !== lastEntry.diag.code) {
                errorMessage ? diag.pushA(error, [errorMessage]) : diag.push(error);
            }
        }
        else {
            errorMessage ? diag.pushA(error, [errorMessage]) : diag.push(error);
        }
    }
}
exports.CompileTask = CompileTask;
class CompileTaskForWatch extends CompileTask {
    run(context) {
        return this.runBuild(context, false).then(() => {
            const fileWatcher = new pcfFileWatcher_1.PCFFileWatcher;
            fileWatcher.start(context);
            this.runBuild(context, true);
        });
    }
}
exports.CompileTaskForWatch = CompileTaskForWatch;
