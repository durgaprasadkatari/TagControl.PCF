"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs-extra");
const diagnosticMessages_generated_1 = require("../diagnosticMessages.generated");
const locale_1 = require("../generated/locale");
const constants = require("../constants");
const manifestProcessor_1 = require("../manifestProcessor");
class CreateOutputTask {
    getDescription() {
        return locale_1.translate(diagnosticMessages_generated_1.strings.task_generate_build_outputs.key);
    }
    setOptions(options) {
        this._options = options;
    }
    run(context) {
        const outDir = context.getOutDir();
        if (!outDir) {
            context.getDiagnostic().push(diagnosticMessages_generated_1.strings.buildconfig_no_outdir);
            return Promise.reject();
        }
        return context.mapControls((control) => {
            return this.copyResourcesToOutdir(control, outDir, context.getDiagnostic());
        });
    }
    // Copy all control's resources (except code) and preview-image (if present) to output folder; process names if necessary
    copyResourcesToOutdir(context, outDir, diag) {
        const controlOutputDir = path.join(outDir, context.getControlFolderName());
        fs.ensureDirSync(controlOutputDir);
        const controlPath = context.getControlPath();
        const processor = new manifestProcessor_1.ManifestProcessor(context.getControlManifest().getManifestData(), controlPath, diag);
        const result = processor.getProcessedManifest();
        if (diag.hasErrors()) {
            return Promise.reject();
        }
        const processedManifest = result.processedManifest;
        const resourcesMap = result.resourcesMap;
        const processedXmlString = processedManifest.getManifestXmlString();
        const processedManifestPath = path.join(controlOutputDir, constants.PROCESSED_MANIFEST_FILE_NAME);
        fs.writeFileSync(processedManifestPath, processedXmlString);
        let relativePaths = context.getControlManifest().getResources(false);
        const previewImagePath = context.getControlManifest().getPreviewImagePath();
        if (previewImagePath) {
            relativePaths = relativePaths.concat(previewImagePath);
        }
        const copyResourcesResults = relativePaths.map((relativePath) => {
            const processedPath = resourcesMap[relativePath];
            const desPath = path.join(controlOutputDir, processedPath);
            fs.ensureDirSync(path.dirname(desPath));
            const resourcePath = path.resolve(context.getControlPath(), relativePath);
            if (!fs.existsSync(resourcePath)) {
                diag.pushA(diagnosticMessages_generated_1.strings.resource_file_not_found, [resourcePath]);
                return Promise.reject();
            }
            else if (fs.statSync(resourcePath).isDirectory()) {
                diag.pushA(diagnosticMessages_generated_1.strings.path_must_be_file, [relativePath]);
                return Promise.reject();
            }
            else {
                fs.copyFileSync(resourcePath, desPath);
                return Promise.resolve();
            }
        });
        return Promise.all(copyResourcesResults);
    }
}
exports.CreateOutputTask = CreateOutputTask;
